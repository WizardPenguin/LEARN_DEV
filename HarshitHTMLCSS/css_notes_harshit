1. how to take fonts 

fonts.google.com ----> select-style ----> embed ----> copy the link ----> paste in html file in head section
use that in CSS file,
or just directly import in CSS


font-size : 

default : 16px...
line-height : 
word-spacing : 
letter-spacing : 
font-weight : ( only those available which are downloaded from google fonts)


box model : 

border : top/bottom left/right type color 
    or : top right bottom left ( top clockwise)

padding : content vs border 
margin : border vs outside

margin collapse : when two margins meet, the larger margin is applied

display :

block level elements gets height width margin padding 

inline elements only get padding margin that too only left and right 

inline-block : behaves like inline but gets height width margin padding



specificity : !important > inline style > id > class > element

default styles which can be removed by unversal selector 
*{
    margin:0;
    padding:0;
    box-sizing:border-box;
}

CSS inheritance : some properties are inherited by default like font-family color etc but some are not like margin padding border etc


box-sizing : content-box (default) vs border-box (includes padding and border in width and height)

pseudo-classes : hover active visited first-child last-child nth-child etc
specifices some state of element 


LVHA order is required....
:link ---- links that hasn't been visited 
:visited ----- when we have visited that link
:hover ---- going over link
:active ---- when link is clicked, can be used with anyting, so we can observe in button

pseudo-classes with input : 
:focus ---- when input box is selected
:checked ---- when checkbox or radio button is selected
:disabled ---- when input box is disabled
:enabled ---- when input box is enabled
:recquired ---- when input box is required ( this can be given in HTML, and similarly access in CSS)


they work w.r.t parent. 

:nth-child(n) ---- selects nth child of parent ( can be even odd etc too)
:first-child ---- selects first child of parent
:last-child ---- selects last child of parent   
:nth-of-type(n) ---- selects nth child of parent of same type
:first-of-type ---- selects first child of parent of same type

p:first_child --- selects p which is first child of parent( p should be first child)
p:first-of-type ---- selects first p of parent ( even if its not first child)


:not(selector) ---- selects everything except that selector.. 

body :not(p) --- inside body everything not p 

:empty ---- selects elements which have no children ( including text nodes)



pseudo-elements : ::before ::after ::first-letter ::first-line etc
they create virtual elements inside selected element

::before ---- creates virtual element before content of selected element
::after ---- creates virtual element after content of selected element
::first-letter ---- selects first letter of selected element
::first-line ---- selects first line of selected element
::selection ---- selects the portion of element which is selected by user


this is inside p, but before any of content of p.
p::before{
    content:"Hello ";
    if we make it's display block, then it's just a new element before it, which can have anything.
}

image,br,input,hr are self closing, and cannot have ::before and ::after pseudo elements.


Units ::::

absolute units : cm mm in px pt pc

1inch == 96px/1in
      == 2.54cm

1px = 0.75pt... so pt is a small unit

relative units : % em rem vw vh vmin vmax ch ex

% : relative to parent element ( eg font-size = 100% == 16px as default font size is 16px)

eg width : 50% ---- means 50% of parent width, if margin auto, then it will center the element

rem : relative to root element font size ( html element font size)
root is html and default at 16px so 1rem == 16px 
or we can change html font size to 10px, then 1rem == 10px..
better font-size : 62.5% .... makes it changable with user settings.. 



em : relative to current element font size 
if used with font size : 
    parent font size : 16px
    current element font size : 20px
    child element font size : 2em == 40px ( 2 * 20px)
it's good, if we changes font size inside some element, then it's other properties also change accordingly.


for font size : rem is better, for other properties em is better.
for padding/margin : em is better. as they adjusts according to font size of element.
layouts, meaing keep left or right etc ... : % works good. 

vw, vh : relative to viewport width and height eg 100vw == viewport width ( independent of parent)
vmin, vmax : relative to minimum and maximum of viewport width and height

used in responsive website design. where our layout changes according to viewport size( mobile, tablet, desktop etc)


FLOATS AND CLEARING : 
float : left right none etc
when we float an element, it comes out of normal flow, and other elements comes up to fill that space.
so to avoid that we use clear property.

let's we have a div with float left, and some text after that div.
the text will come up to fill the space of div. ( text starts from right... till left element ends, and then normal space taken to fill doc)
so to avoid that we use clear property on that text element.


that extra thing needs to be cleared is called "float drop"
so we can use clear:left/right/both/none
to avoid that float drop, we can use clear:both on that element.
then element will start after floating elements ends, and take full width.


and best way is to have a empty element inside parent div after floating elements with clear:both
we can do it via after pseudo element also. that way everything will look inside parent as whole area will be covered.

:after{
    content:"";
    display:block;
    clear:both;
}


CSS positions : static relative absolute fixed sticky
static : default position, normal flow
relative : relative to it's normal position, can use top left bottom right to move it from normal position
absolute : relative to nearest positioned ancestor ( non static) , if none then relative to document body
fixed : relative to viewport, stays in same position even on scroll
sticky : behaves like relative until a certain scroll position, then behaves like fixed 


relative : with left/right/top/bottom it moves x pixesl from it's original position, but still occupies same space in normal flow.
changing it like this and moving can move it over other elements... 
but other elements keep it's space as it was in normal flow.

absolute : with left/right/top/bottom it moves x pixels from nearest positioned ancestor.
it comes out of normal flow, so other elements comes up to fill that space.
if no positioned ancestor, then relative to document body.
    so we need to give relative to parent, so this element moves w.r.t that parent only.

parent {
    position:relative;
}
child {
    position:absolute;
    top: 50%;
    left:50%;
    transform: translate(-50%,-50%);  // to center exactly
    // translate moves element w.r.t it's own size.
}

fixed : with left/right/top/bottom it moves x pixels from viewport.
it comes out of normal flow, so other elements comes up to fill that space.
it stays in same position even on scroll.
so used in navbars, back to top buttons etc.

z-index : controls stacking order of elements.
only works on positioned elements ( non static)
higher z-index means element will be on top of lower z-index elements.
if same z-index, then later in code will be on top.


sticky : with top/bottom it moves x pixels from viewport when we scroll past it.
until that point it behaves like relative, after that point it behaves like fixed.
so used in sticky navbars etc.
if disappears when it's container is out of view.


FLEX BOX: 

container has to have a display property 

display : flex or inline-flex 


Then we need to decide flex direction, in which direction will it's immmediate childrens flow

flex-direction 
        : row,column, row-reverse, column-reverse


then we need to see if we have many itself for single row/col then in which direction they'll flow

flex-wrap 
        : nowrap (normal) ---- all flex item will be in one line might overflow 
        : wrap ---- splits into multiple lines from top to bottom 
        : wrap-reverse --- splits from bottom to top.

flex-flow : row/col/col-reverse/row-reverse nowrap/wrap/wrap-reverse 



now it's time for spacing between immediate childrens

justify-content 
        : flex-start ----- stick to flex start of flex direction 
        : flex-end ----- end of flex direction 
        : center ---- centered along main axis
        : space-between ---- first/end item stick to ends, and other's distribute space in between
        : space-around ----- each element takes equal space on each of it's side. 
                ---- note they won't seem equal, because each have 1 unit on left right
                ---- so middle space = 2 units as one of left and one of right element.
        : space-evenly
                ---- this will have equal space 1 unit in between element, visually equal.

        
now let's see alignment/justification along cross axis

align-items 
        : streach ( take whole row streach to max-width)
        : flex-start ( sticks on start of cross axis)
        : flex-end
        : center ( items are centered in the cross-axis)
        : baseline; ( aligns such that their baseline aligns, meaning their text bottom etc.)


finally it's time to justify wrap 
    ( so content works on rows/colms ( justify-content, align-content), alignment mean width direction)

align-content 

    : flex-start 
    : flex-end
    : center 
    : space-between 
    : space-around 
    : space-evenly 



finally we have children properties 

default order is same a source order
order = 1 for all 

then we can give order =-1, for element to come first etc.. 


flex-grow : defines how much space item going to take 

flex-grow : 0 by default, and all takes their default sizes and stick according to justify-content 



align-self : specifying alignment of specific element 
            : alignment means movement in vertical/cross axis




            ############################ flexbox via harshit ################################

flexbox is more powerful than floats , floats needs clearing and stuff like that..
tables were used before this...

when container takes flex :  childrens behaves like inline elements, takes only width that it's items needs

display : flex ; ####### container get's this property 

flex items goes in direction of main axis, other axis is cross axis....
    main-start, main-end, cross-start, cross-end.

flex-direction : row ; main axis goes from left to right.... 

flex-wrap : used when we have element overflowing, by default flex adjusts them in single row,
    but using wrap we can make that content to flow in cross axis direction 
    : wrap=reverse -----> changes the direction of cross axis

by default each flex item takes complete width ------ meaning streach on corss axis, if there's single row ( no wrap)


justify-content : moves items in main axis direction

justify  from  flex-start or flex-end..... space betwerre etc... 


justifying in cross axis when no wrap......... then it's different so 

align-item ----this streaches in direction of cross axis so flex start/end means w.r.t cross here.

align-item ----- works for single row ( item ), 




containers property ;;;;;

align-self ---- overrrides align-item and help giving corss axis movement to single element.

order =0 for all by default, 
smaller order comes closer to flex-start, and other's goes far


flex-basic ------ starting width of item in direction of main axis, so different from width
            ------ basic length given in that direction is ovverriten by it.

flex-grow --- defines how remaining empty space going to be distributef
    ---- it provides ratio by which this distribution is to be done, default = 1
    ---- that space is divided int hat ration and using that space elements increases their sizes
    ---- in responsiveness when that space starts decreasing element also changes accordingly in corresponding ration


somewhat similar is flex-shrink, defines when spaces starts loosing, who's going to loose it's width at what rate.


flex : flex-grow flex-shrink flex-basic




CSSSS animation : 


changing from one style to another..... 

animation-name : change-bg-color;
amimation-duration : 5s; ### important otherwie there won't be any transiton
animation-delay : 3s; ----- starts after 3 seconds of loading
animation-iteration-count : 3 -------- number of time animation repeats, but here going back to original happen quickly without transition.
amimation-fill-mode : forwards -------- it remains in state animation too it to, no comming back.
amimation-direction : reverse ----- animation goes in reverse if fill mode forward, then it ends at (from) properties.

defining keyframe : defines at some interval what is state of element 

@keyframes change-bg-color {
    from {
        background : red;
    }
    to{
        background : yellow;
    }
}

we can also make animation for width change etc....

@key-frames grow-width {
    from {
        width: 0;
    }
    to {
        width:150px
    }
}


let's say we want thing to move in square , we can set style for percentage of time. ( remember animation time.)
animation-iteration-count : infinite; also works.....

element need to have position relative ----- so we can move it w.r.t it's original position..
@keyframes move-around{
    0% {
        top: 0;
        left: 0;
    }
    25% {
        top: 0;
        left: 300;
    }
    50% {
        top: 300;
        left: 300;
    }
    75% {
        top: 300;
        left: 0;
    }
    100% {
        top: 0;
        left: 0;
    }
}

animation-timing-function : ease-in   -> animation starts slowly
    ease-out ------> animation ends slowly
    ease-in-out ------> animation start and ends slowly

animation-fill-mode : forward; ( end state is retained...)




animation : name duration fill-mode delay iteration-count timing-function ;









##################################### css trasitions ###########################
changing of state on some event : hover/focus etc....

.box : hover {
    background: red;
}

now when we hover color directly changes to red, but we want it to animatte
it works both ways, when property changes back, it still transits...


.box {
    transition-property : background;
    transition-duration : 1s;
    transition-timing-function: ease-in-out;
}

short ===== transition : background 500ms ease-in-out;


transition : background 1s ease-in-out, width 1s ease-in-out;......
transition : all 1s ease-in;



######################### tranformation ##########################################
rotate,skew,scale,transate..
usually used with transition, when some property changes then transition triggered...

transition: tranform 1s ease-in-out;

:hover {
    tranform : rotate(20deg);  ( for reverse use -20deg)
}


:scaleX(time)

:scaleX(2)
:scaleY(2)
:scale(2) ---- both direction double...
:scale(1.5,2); --- both direction but different values..



:translate(); ======= changing position left,right,top,bottom....

:translateX(50px);
we can also use percentages with it....
:translateX(-50%); --> move left 50% width of element on which property being applied.
:translate(20px,-20px);



:skew() ====== along x axis or along y axis 

:skewX(20deg) ----- keep x axis stable move y 20deg anti-clockwise. 



on what point does these tranforms happens 

origin --- center of object based on height width .... 

we can change this origin 

tranform-origin : top left; ( then rotate it'll rotate from top right)
                : 10px 10px ( 10px from left, 10px from top.)





overlays : a extra screen that floats over some element 
we'll use transition/animation/tranform for these. 

