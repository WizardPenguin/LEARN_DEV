import { useCallback } from "react"

 JS : 

 started with a front end development languages like JScript or java script 

 then ECMA strandarized browers rendering languages as JS.
 JS from 2015 onwards released new version each time... 


JS different from java

java is more wast can be used for web/android developments etc.. 
it's used in high end development of backends etc... 


but JS is also popular as it provides both web/android(react).. 



CTRL shift + j is to open console. 

JS should be added at end of body ?? why ?? 


console.log(anything to print string,variable,etc);

variables ::: 
to store something.. 

var firstname = "harshit" ---> string collection of characters inside quotoes,single quotes, backticks ( used in template strings)

*** names of variables are case sensitives... 

variables values can be changed


**** variables neednot use var, we can directly use 
firstname = "raman"

....... this is problematic, as we can use some different names etc... 

so we explicitly tell JS to use strict mode, to save from mistakes 

"use strict"; 
now directly writing 
firstname = 'raman' ---- tells error firstname not defined.


Rules for naming variables :: :: :: 

can't start with number 
but can use Dollar $ or underscore _ 
anything can be used in middle.. or ending..... digits,characters,$,_

** can't use space replacement is ,

use camel case ---- firstName  [ convension is to start with small letter, then follow camel case], classes starts with Capital first...
use snake case ---- first_name



##### using let keyword 

let firstname = 'x'

---- let allows it to be in function scope, and var does it in global scope.
---- let can't be used again for same variable.. but var can be...  : Identifier 'firstname' has already been declared.


##### declaring constant 

---- values which can't be changed 

const pi = 3.14 .... 

if we do 
    pi = 4 ... uncaught typeError : Assignment to constant variable.


##### strings 
strings has characters indexed from 0. 
my_string.length
my_string[index] ---- to access a charater

#### string manipulation 

trim() 
toUpperCase()
toLowerCase()
slice()


###### string template 
passing variables names inside string 

`name is {name}`


###### undefined 
let firstname ---- it has been declared but not intialized, it's type is undefined
var also goes undefined.. 

##### null 
typeof(null) ----> object it's a bug, as lots of code written considering this, so this is still a bug.
but it's a datatype 
but why used :::.. 


##### BigInt() a new premitive datatype in JS
myNumber = BigInt(12); or 12n.

remember, mix bigInt and other datatype can't be added 
error : mix bigint with other datatypes, use explicit conversion. 


##### Boolean comparision :: 
T/F operations... 

let num1 = true; 
let num1 = 5 > 7;

equality num1 == num2... 

num1 == num2 ======> it checks datatype and value, so it's more strict, as don't do implicit typecasting.. 

!= , !== are also same.... firs they need same dtype only then operation performed.

##### truthy and falsy values.. 

falsy values ----> 
false 
""
null
undefined 
0

everything else is a truhy value..

##### if/else conditions... 

if () {

} else {

}

##### ternary operator .

let dring = (age > 5)?"coffee":"milk";

#### and and or operatior 
&&
||
if(firstName[0] === "H" && age > 18) {
    console.log("someone greater than 18 with H");
}

#### prompt 
let userFuess = prompt("Guess a number");
---- type of value given by prompt is string **


#### else if 

if {}
else if {}
else {}

#### switch case 

switch(day) {
    case 0:
        .. 
        break;
    default : 
        ..
}


#### while loop 
let i = 0;
while(i<-3){
    console.log(i);
    i++;
}

#### for loop 
i is not defined outside scop of for, as we have used let.
for(let i = 0; i < 3; i++) {
    console.log(i);
}
if we had used var, then variable was allowed outside..


#### continue and break; 

break; ---> we come out of control statement, transfer control outside loop.. 
continue; --> can only be used within loops not switch statement. ( skips remaining statements of that iteration)

### do while loop.....

do {
    console.log(i);
    i++;
} while(i<9);

###### arrays --- it's a referency type, they are also called object..
ordered collection of items ( mix datatypes also allowed)

let fruits = ["apple", "mango"];
let number = [1,2,3,4, "five"]

fruits[0] ---> apple
fruits[1] ---> mango


### relpacing element at some index ( arrays are mutable)
fruits[1] = "banana"......

### type of array 

typeof fruits ----> object 

### how to check if it's really array, as every reference is of type fruits.. 

Array.isArray(fruits) ----> 


### methods in array 
push,pop  ---> they are methods that can mutate array
## this doesn't happen in premitive datatype meaning string etc....

fruits.push("grapes");
let last_element = fruits.pop();

### adding element at starting 

fruits.unshift("banana"); ... adds new eleemnt at start 

fruits.shift() ----> remove element from start.. 

#### push and pop are faster, compared to shift and unshift.. 


### premitive and reference type variables 

let num1 = 6; 
let num2 = num1; 

num2 = 7; ## won't change num1... as it's premitive so they are created new.. 

let arr1 = [1]
let arr2 = arr[1] 
arr1.push(2) 
will alter arr2 too, as they are storing references.. 


Premitives are stored in stack...  they don't take lots of memory, so they are copied in each operation instead modiying tehmselves
reference types are stored in Heap... they are heavy, when copied they stores refenrece ( address ), so refers same item.

to check if they refers same thing we can use 

if(array1 === array2) .... ? checks if they are exact same object in memory
if we want deep comparision -----> we need to stringify so whole string/structure/values are compared..

#### creating a clone.... 

let arr2 = arr1.slice(0); ---> slice of array returned as new object starting with index 0.

let arr2 = [].concat(arr1) ---> this concatenates arr1 to a emtpy array and returns that emtpy array with values.

# new way. spread operator

let array2 = [...array1] ------ it's like mannually writing all values... ( slice is better, this used more as more redable)

### clone and add few more items 

let arr2 = arr1.slice(0).concat(["item3","item4"])
            = [...arr1, "item4","item5"]


### for loop in array.. it iterate it's elements.. 

for(let i=0; i<fruits.length; i+=1) {
    console.log(arr1[i].toUpperCase());
}

##### using const for creating array

const fruits = [...]
fruits.push("s") ----> this is also a valid thing 

because fruits is a refenrece, we can't change it's reference but we can change values.

fruits = ["new array"] ----> this is error, as how we are trying to change reference... 
const are safer for reference type..



#### for of loop ---- 

for( let fruit of fruits) {
    cosole.log(fruit);
}

#### for in loop  ----- avoids explicitly wroting for loop ending till length.. 
for(let index in fruits) {
    console.log(fruits[index]);
}

#### array destructuring.... 

spliting array into indivisual elements, that can be used to copy or stuff like that.. 

let [myvar1, myvar2] = myArray; 

it simplifying decraring 2 variables and then initializing it to some index.. 

case : 
if myArray is of larger size, only 2 elements copied
if array is of smaller size, then remaining variable becomes undefined 
if we need value at some index 
    let [myvar1, , myvar2] = myArray
if we want rest all values in some other variable, also it should be type array 
    let [myvar1, myvar2, ...myNewArray] = myArray;


###### objects in JS .....
they are used to store data in key-value pairs... 

const person = {
    name : "harshit", age : 22
};

### object formed using curly bracse is called object literal.

we can access using 

person.key ------ ( key is also called properties...)

#### modifying object 
1. how to add key value pair
person.gender = "male";
person["person"] = [1,2,3];

2. accesing key , in JS key is by default in form of key, we needno't specify explicitly in literal 
person["name"] ------
person.name

cases : 
if we want key to have spaces *** we need to use key_notation dot notation won't work. we need to consider it as string.

let key = "something; 
person[key] = "thing"
. now key is going to be computed, meaning value of key(something) is going to be our key. 


#### iterating objects ... 
___ for in loop

for(let key in person){
    person[key] ----> so value of key is used as key to find value in key.
    console.log(`${key} : ${person[key]}`);
    console.log(key,person[key])
}

____ using object.keys 

Object.keys(persno) ---> returns a array with keys.. 

we can check it's type using Array.isArray(Ojbect.keys(person))

for(let key of Object.keys(person)) {
    ....
}

###### spread operators 
iterables are going to be spreaded like this ..

[...array, new1, new2]
[..."abc", "d",  "e"]


how does it works in object. 

*** in objects there can't be more than 1 key. if we write it again, then obviosly later value will be stored. 

objects spreads like they are initialized, key : "value, .... like this.. 

newObject = [...object1, ..ojbect2 , keynew : "valuenew"] 
// if similar keys are there, then object2 value will take preference.


if we do it like this 

newObject = [..."abc"] ----> then index 0,1,2 becomes key, and a,b,c are taken as values.... 

that way we can convert our array into objects .. 

newObject = { ...["item1", "item2"]}  ---- easy way to make values with numeric indices of 0...n 



##### object destrucuring... 

const {bandName, famousSong} = band; ( key's value are stored in these variables...)

* if we have more keys, then they won't give any affect.. 
* if we don't want variable name same as key, we can do it like this 
    let {bandName:var1, famousSong : var2, ...restPropsInObject} = band;


###### let's see array inside object for netted destructuring.. 

const users = [
    {
        name : "x",
        age : 2
    },
    {
        name : "y",
        age : 3
    }
];

** destructuring from inside array
const [ user1, user2] = users

** let user1.name, user2.age. 

cosnt [{name:user1Name}, , {age}] = users; 


##### 43

##### declaring functions in JS

function isEven(number) {
    if(number%2 == 0){
        return true;
    }
    return false;
}

##### function expression 

const isEven = Function(number) {
    if(number%2 == 0) return true;
    return false;
}

#### arrow functions. 
we just avoid using Function by using => after () 

const firstChar = (anyString) => { return anyString[0]};

### when we have single parameter then we can avoid brackets

const isEven = number => { return number%2 == 0};

### if we have single return statement we can event avoid it. 

const isEven = number => number%2 == 0; ----> consider like converts number to number%2 === 0


### Hoisting .... 

if function defined like 
    function(){

    }

it can even be refered before declaration.... 


## but if you are using expression or something like that to declarate it in a variable, then it can't be 
const func = function() { }


#### remember 

if we use let, const to define some variable, then accessing it before declaration is a error 
but if we use var, then accessing it before declaration just makes it undefined.


## lexical environment.....

whenever we use some variable, first it searches for it in local memory, if not found then in outer memory, and so on till global memory.

if variable not found in any memory, then it's error.

so if it finds a local variable with same name as global variable, then local variable is used. 

##### block scope vs function scope

variables defined using let and const are block scoped... 
variables defined using var are function scoped...

block scope means inside if, for , while etc... 

function scope means inside function only...

so if we define variable using var inside if block, then outside if block it's accessible.. 
but if we define variable using let inside if block, then outside if block it's not accessible...

### try creating function with var inside it, and call it twice, it retains value from previous call...
### will it create again, as var is function scoped... yes it creates again, but as var is hoisted, so previous value is retained...
what does it mean var is hoiisted... it means variable is created at top of function with undefined value, so when we assign value to it, it retains previous value from last call...



##### default parameters 

function sum(a,b=0){
    // previously 
    if(typeof b === 'undefined'){
        b = 0;
    }
    return a+b;
}

##### rest parameters, remaining all parameters. 

function sumAll(...numbers){
    // numbers is an array of all parameters passed
    let sum = 0;
    for(let number of numbers){
        sum += number;
    }
    return sum;
}

##### parameter destructuring 

function printDetails({name, age, gender}){
    console.log(name, age, gender);
}

let person = {
    name : "harshit",
    age : 22,
    gender : "male"
};

printDetails(person);
## it's same destructuring that we did for objects earlier... 

##### callback functions 

function greet(name, callback){
    console.log("Hello ", name);
    callback();
}

function callMe(){
    console.log("I am callback function");
}

greet("harshit", callMe);

##### functions returning functions

function multiplyBy(factor){
    return function(number){
        return number * factor;
    }
}

let multiplyByTwo = multiplyBy(2);
console.log(multiplyByTwo(5)); // 10

let multiplyByThree = multiplyBy(3);
console.log(multiplyByThree(5)); // 15

# it kind of hides factor variable in closure... 






####################### array methods 

let's we have to call a funtion for each element of array...
it's return value is not stored anywhere..

array.forEach( callbackFunction )

let numbers = [1,2,3,4,5];
numbers.forEach(function(number, index){
    console.log(number, index);
});

it also works on objects... 

let person = {
    name : "harshit",
    age : 22,
    gender : "male"
};

Object.keys(person).forEach(function(key){
    console.log(key, person[key]);
});


##### map function

let numbers = [1,2,3,4,5];
let squares = numbers.map(function(number){
    return number * number;
});
console.log(squares); // [1,4,9,16,25] --- creates a new array with return values.
---- by default return is undefined

##### filter function

let numbers = [1,2,3,4,5,6];
let evenNumbers = numbers.filter(function(number){
    return number % 2 == 0;
});
console.log(evenNumbers); // [2,4,6] --- creates a new array with elements satisfying condition.

##### reduce function

let numbers = [1,2,3,4,5];
let sum = numbers.reduce(function(accumulator, currentValue){
    return accumulator + currentValue;
}, 0); // 0 is initial value of accumulator
// if no initial value given, then first element is taken as initial value and iteration starts from 2nd element.
console.log(sum); // 15 --- reduces array to single value by applying function.

##### find function

let numbers = [1,2,3,4,5];
let firstEven = numbers.find(function(number){
    return number % 2 == 0;
});
console.log(firstEven); // 2 --- returns first element satisfying condition.

##### some and every functions

let numbers = [1,2,3,4,5];
let hasEven = numbers.some(function(number){
    return number % 2 == 0;
});
console.log(hasEven); // true --- checks if any element satisfies condition.

let allEven = numbers.every(function(number){
    return number % 2 == 0;
});
console.log(allEven); // false --- checks if all elements satisfy condition.    



##### sort method , this change original array
let numbers = [5,3,8,1,2];

default sort is lexicographical
numbers.sort();
console.log(numbers); // [1,2,3,5,8] but for [10,2,3] it gives [10,2,3] as 1 comes before 2 lexicographically

how does it works?
if a-b > 0 then b comes before a
if a-b < 0 then a comes before b
if a-b == 0 then no change
-ve mean don't swap 

numbers.sort(function(a,b){
    return a - b; // ascending order
});
console.log(numbers); // [1,2,3,5,8]

numbers.sort(function(a,b){
    return b - a; // descending order
});
console.log(numbers); // [8,5,3,2,1]        

## let's we don't want to change original array, then we can use spread operator or slice to create a copy
let sortedNumbers = [...numbers].sort(function(a,b){
    return a - b;
}
or 
let sortedNumbers = numbers.slice().sort(function(a,b){
    return a - b;
});


##### find method to find index of element satisfying condition
we can also use find() to find first value satisfying condition, but if we want index of that element, then we can use findIndex()

let numbers = [1,2,3,4,5];
let firstEvenIndex = numbers.findIndex(function(number){
    return number % 2 == 0;
});
console.log(firstEvenIndex); // 1 --- returns index of first element satisfying condition.      

const myUser = users.find((user) => user.userId == 3);


##### fill method 
used to initialize array with some value
let arr = new Array(5); // creates array of size 5 with undefined values
arr.fill(0); // fills all elements with 0
console.log(arr); // [0,0,0,0,0]

let arr2 = new Array(5).fill(1); // creates array of size 5 with all elements as 1
console.log(arr2); // [1,1,1,1,1]

let arr3 = [1,2,3,4,5];
arr3.fill(0, 1, 4); // fills elements from index 1 to 3 with 0
console.log(arr3); // [1,0,0,0,5]


##### slice to insert or delete elements in array without mutating original array
let arr = [1,2,3,4,5];
let newArr = [...arr.slice(0,2), 10, 20, ...arr.slice(2)];
console.log(newArr); // [1,2,10,20,3,4,5] --- inserts 10 and 20 at index 2

let newArr2 = [...arr.slice(0,2), ...arr.slice(3)];
console.log(newArr2); // [1,2,4,5] --- deletes element at index 2   

##### splice method to insert or delete elements in array mutating original array
let arr = [1,2,3,4,5];
arr.splice(2, 0, 10, 20); // inserts 10 and 20 at index 2
console.log(arr); // [1,2,10,20,3,4,5]

arr.splice(2, 2); // deletes 2 elements from index 2
console.log(arr); // [1,2,4,5]


##### iterables and array like objects 

iterables are objects that can be iterated over, such as arrays, strings, maps, sets etc.
we can use for...of loop to iterate over iterables

let str = "hello";
for(let char of str){
    console.log(char);
}

array like objects are objects that have length property and indexed elements, such as arguments object, NodeList etc.
we can convert array like objects to arrays using Array.from() or spread operator

function myFunc(){
    let argsArray = Array.from(arguments);
    // or let argsArray = [...arguments];
    console.log(argsArray);
}
myFunc(1,2,3); // [1,2,3]

##### sets in JS
sets are collections of unique values, they can store any type of values, whether primitive or reference types.
we can create a set using new Set() and add values using add() method.

let mySet = new Set();
mySet.add(1);
mySet.add(2);
mySet.add(2); // duplicate value, won't be added
console.log(mySet); // Set {1,2}

we can check if a value exists in set using has() method
console.log(mySet.has(1)); // true
console.log(mySet.has(3)); // false

we can delete a value from set using delete() method
mySet.delete(1);
console.log(mySet); // Set {2}

we can get size of set using size property
console.log(mySet.size); // 1

we can iterate over set using for...of loop
for(let value of mySet){
    console.log(value);
} // 2

we can convert set to array using Array.from() or spread operator
let myArray = Array.from(mySet);
// or let myArray = [...mySet];
console.log(myArray); // [2]


## object in JS 

Objects are collections of key-value pairs, where keys are strings (or symbols) and values can be any type of data,
including other objects or functions.

let person = {
    name: "John",
    age: 30,
    isStudent: false,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

we can access object properties using dot notation or bracket notation
console.log(person.name); // John
console.log(person["age"]); // 30

we can add new properties to object
person.gender = "male";      
person["country"] = "USA";

we can delete properties from object
delete person.isStudent;

we can iterate over object properties using for...in loop
for(let key in person){
    console.log(key + ": " + person[key]);
}

we can get array of object keys using Object.keys()
let keys = Object.keys(person);
console.log(keys); // ["name", "age", "greet", "gender", "country"]

we can get array of object values using Object.values()
let values = Object.values(person);
console.log(values); // ["John", 30, function() { ... }, "male", "USA"] 

we can get array of object entries using Object.entries()
let entries = Object.entries(person);   
console.log(entries); // [["name", "John"], ["age", 30], ["greet", function() { ... }], ["gender", "male"], ["country", "USA"]]


###### map in JS

Maps are collections of key-value pairs, where keys can be of any type, including objects or functions.

let myMap = new Map();
myMap.set("name", "John");
myMap.set(1, "one");
myMap.set(true, "boolean true");

we can get value from map using get() method
console.log(myMap.get("name")); // John
console.log(myMap.get(1)); // one

we can check if a key exists in map using has() method
console.log(myMap.has(true)); // true
console.log(myMap.has(false)); // false

we can delete a key-value pair from map using delete() method
myMap.delete(1);
console.log(myMap.has(1)); // false

we can get size of map using size property
console.log(myMap.size); // 2

we can iterate over map using for...of loop
for(let [key, value] of myMap){
    console.log(key + ": " + value);
} // name: John, true: boolean true

we can convert map to array using Array.from() or spread operator
let myArray = Array.from(myMap);
// or let myArray = [...myMap];
console.log(myArray); // [["name", "John"], [true, "boolean true"]]

**** for in vs for of
for...in loop is used to iterate over object properties, it gives keys of the object.
for...of loop is used to iterate over iterable objects like arrays, strings, maps, sets etc., it gives values of the iterable.


#### cloning object 

let original = { a: 1, b: 2, c: 3 };

// spread operator
let clone = { ...original };

// using Object.assign()
let clone1 = Object.assign({}, original);

// using spread operator
let clone2 = { ...original };

// both clone1 and clone2 are shallow copies of original object

##### deep cloning object

let original = { a: 1, b: { c: 2 } };

// using JSON methods
let deepClone1 = JSON.parse(JSON.stringify(original));

// using structuredClone (modern browsers)
let deepClone2 = structuredClone(original);

// both deepClone1 and deepClone2 are deep copies of original object    

#### option chaining in JS

let user = {
    name: "John",
    address: {
        city: "New York",
        zip: "10001"
    }
};

// accessing nested property safely using optional chaining
let city = user.address?.city;
console.log(city); // New York

// accessing non-existing nested property
let country = user.address?.country;
console.log(country); // undefined

// calling method safely using optional chaining
let greet = user.greet?.();
console.log(greet); // undefined

// accessing deeply nested property safely
let zip = user.address?.zip?.code;
console.log(zip); // undefined

// optional chaining prevents runtime errors when accessing properties or methods of undefined or null values.

##### methods in objects

let calculator = {
    add: function(a, b) {
        return a + b;
    },
    subtract: function(a, b) {
        return a - b;
    },
    multiply: function(a, b) {
        return a * b;
    },
    divide: function(a, b) {
        if(b !== 0) {
            return a / b;
        } else {
            return "Cannot divide by zero";
        }
    }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
console.log(calculator.multiply(5, 3)); // 15
console.log(calculator.divide(5, 0)); // Cannot divide by zero

##### ways to create methods 
let obj = {
    // method shorthand
    greet() {
        console.log("Hello!");
    },
    // arrow function (not recommended for methods)
    farewell: () => {
        console.log("Goodbye!");
    }
};

obj.greet(); // Hello!
obj.farewell(); // Goodbye!

##### this keyword, how it works in methods

let person = {
    name: "John",
    greet: function() {
        console.log("Hello, my name is " + this.name);
    },
    farewell: () => {
        console.log("Goodbye from " + this.name);
    }
};

person.greet(); // Hello, my name is John
person.farewell(); // Goodbye from undefined

// in greet method, this refers to person object
// in farewell method, this refers to global object (window in browsers), hence undefined

##### binding this keyword

let person = {
    name: "John",
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

let greetFunction = person.greet;
greetFunction(); // Hello, my name is undefined

// binding this to person object
let boundGreet = greetFunction.bind(person);
boundGreet(); // Hello, my name is John

when we create function inside object, this refers to that object 
function kind of binds to that object 

this is what happens on variables, that's why they hoists 
as calling function inside object, this refers to that object only...
and that object has those variables at that time...

function defined using  function  keyword binds this to that object
this can be avoided using strict mode 
function func() {
    "use strict";
    console.log(this); // undefined
}

##### call, apply and bind methods

let person1 = {
    name: "John",
    greet: function(greeting) {
        console.log(greeting + ", my name is " + this.name);
    }
};

let person2 = {
    name: "Jane"
};

// using call
person1.greet.call(person2, "Hello"); // Hello, my name is Jane

// using apply
person1.greet.apply(person2, ["Hi"]); // Hi, my name is Jane

// using bind
let boundGreet = person1.greet.bind(person2, "Hey");
boundGreet(); // Hey, my name is Jane

// call and apply invoke the function immediately with specified this value and arguments
// bind returns a new function with specified this value and arguments, which can be invoked later


###### towards object oriented programming

#### why needed 
let's say we have to create multiple objects with same properties and methods

let person1 = {
    name: "John",
    age: 30,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

let person2 = {
    name: "Jane",
    age: 25,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

// this approach is not scalable and leads to code duplication

#### constructor functions

function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        console.log("Hello, my name is " + this.name);
    };
}

let person1 = new Person("John", 30);
let person2 = new Person("Jane", 25);

person1.greet(); // Hello, my name is John
person2.greet(); // Hello, my name is Jane

// constructor functions allow us to create multiple objects with same structure

#### prototypes

function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log("Hello, my name is " + this.name);
};

let person1 = new Person("John", 30);
let person2 = new Person("Jane", 25);

// what and why is prototype in function object 
person1.greet(); // Hello, my name is John ---- new automatically links __proto__ to Person.prototype
person2.greet(); // Hello, my name is Jane

// prototypes allow us to share methods among all instances of an object

#### 3nd problem with constructor functions is that they are not very intuitive and can lead to confusion with this keyword.
#### if we want to create a class with inheritance, we need to use __proto__ which is not recommended.
// let's see how it happens
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(this.name + " makes a noise.");
};

function Dog(name) {
    Animal.call(this, name); // call super constructor
}
Dog.prototype = Object.create(Animal.prototype); // inherit from Animal
Dog.prototype.constructor = Dog;
Dog.prototype.speak = function() {
    console.log(this.name + " barks.");
};

let dog = new Dog("Buddy");
dog.speak(); // Buddy barks.

// this approach is cumbersome and not very readable

#### object inheritence 
let animal = {
    speak: function() {
        console.log(this.name + " makes a noise.");
    }
};

let dog = Object.create(animal); // sets animal as prototype of dog __proto__
dog.name = "Buddy";
dog.speak(); // Buddy makes a noise.

// this approach is cumbersome and not very readable

#### classes solving these issues.... 

default way was 

function createUser(name, age) {
    const user = Object.create(createUser.prototype);
    user.name = name;
    user.age = age;
    return user;
}
createUser.prototype.greet = function() {
    console.log("Hello, my name is " + this.name);
};
// now using class
// convension to start class name with capital letter, and this is need New keyword to create object
// constructor function is special function that is called when new object is created
// they also follow this convension.
class User {
    constructor(name, age) {
        /// this creates empty object and passes as this.
        /// using new keyword here makes this = Object.create(User.prototype)
        this.name = name;
        this.age = age;
        // automatically returns this
    }
    greet() {
        console.log("Hello, my name is " + this.name);
    }
}

### iterating keys over objet created by constructor function gives keys of prototype also
let user1 = new User("John", 30);
for(let key in user1) {
    console.log(key); // name, age, greet
}
### to avoid this we can use hasOwnProperty method
for(let key in user1) {
    if(user1.hasOwnProperty(key)) {
        console.log(key); // name, age
    }
}

##### getting prototype of object

let proto = Object.getPrototypeOf(user1);

##### inheritance in classes

class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(this.name + " makes a noise.");
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name); // call super class constructor
    }
    speak() {
        console.log(this.name + " barks.");
    }
}

let dog = new Dog("Buddy");
dog.speak(); // Buddy barks.

##### getters and setters in classes

class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    get area() {
        return this.width * this.height;
    }
    set area(value) {
        this.width = Math.sqrt(value);
        this.height = Math.sqrt(value);
    }
}

let rect = new Rectangle(4, 5);
console.log(rect.area); // 20

rect.area = 36;
console.log(rect.width); // 6
console.log(rect.height); // 6

// getters and setters allow us to define computed properties and control access to object properties

##### how javascript engine works

JavaScript engine is a program that executes JavaScript code. It consists of several components that work together to parse, compile, and execute the code.

1. Parser: The parser reads the JavaScript code and converts it into an Abstract Syntax Tree (AST). The AST is a tree-like structure that represents the syntactic structure of the code.

2. Compiler: The compiler takes the AST and converts it into bytecode or machine code that can be executed by the JavaScript engine. Modern JavaScript engines use Just-In-Time (JIT) compilation to optimize the code during runtime.
    for early error checking and determining appropriate scope for variables.

3. Execution Context: The execution context is the environment in which the JavaScript code is executed. It consists of the variable object, scope chain, and this value. Each time a function is called, a new execution context is created.

4. Call Stack: The call stack is a data structure that keeps track of the execution context of functions. When a function is called, its execution context is pushed onto the call stack. When the function returns, its execution context is popped off the stack.

5. Memory Heap: The memory heap is a region of memory where objects and variables are stored. The JavaScript engine manages memory allocation and garbage collection to free up memory that is no longer needed.

6. Event Loop: The event loop is responsible for handling asynchronous operations in JavaScript. It continuously checks the call stack and the task queue for any pending tasks and executes them when the call stack is empty.`

#### hoisting in JS

js already knows which variable has what scope before executing code ( during compilation)
so it allocates memory for variables and functions before executing code.

1. Variable Hoisting:
   - Variables declared with var are hoisted to the top of their function scope and initialized with undefined.
   - Variables declared with let and const are hoisted to the top of their block scope but are not initialized. Accessing them before declaration results in a ReferenceError.

2. Function Hoisting:
   - Function declarations are hoisted to the top of their scope and can be called before they are defined.
   - Function expressions (including arrow functions) assigned to variables are not hoisted. Accessing them before declaration results in a ReferenceError.

// Example of variable hoisting
console.log(x); // undefined
var x = 5;

console.log(y); // ReferenceError: Cannot access 'y' before initialization, in global execution context they are uninitialized. 
// they are present in memory but uninitialized.
// time period between creation phase and execution phase is called temporal dead zone
// meaning till variable is initialized, it is in dead zone
// if it was not present in memory, then it would be ReferenceError: x is not defined
typeof y; // ReferenceError: Cannot access 'y' before initialization
but if it's not initatilized even after this phase, then typeof gives undefined
let y = 10;

// Example of function hoisting
greet(); // "Hello!"
function greet() {
    console.log("Hello!");
}

farewell(); // TypeError: farewell is not a function
var farewell = function() {
    console.log("Goodbye!");
};

// Understanding hoisting helps avoid unexpected behaviors in JavaScript code.

##### scope chain in JS

Scope chain is the hierarchy of scopes that determines the accessibility of variables and functions in JavaScript. When a variable or function is referenced, the JavaScript engine looks for it in the current scope and then moves up the scope chain until it finds the reference or reaches the global scope.

1. Global Scope: Variables and functions declared outside of any function or block are in the global scope and can be accessed from anywhere in the code.

2. Function Scope: Each function creates a new scope. Variables and functions declared within a function are only accessible within that function and its nested functions.

3. Block Scope: Variables declared with let and const within a block (e.g., if, for, while) are only accessible within that block.

###### global execution context

When a JavaScript program starts executing, the global execution context is created. It consists of two phases: the creation phase and the execution phase.

1. Creation Phase:
   - The JavaScript engine creates the global object (window in browsers, global in Node.js).
   - It creates the 'this' keyword, which refers to the global object.
   - It allocates memory for variables and functions declared with var, let, const, and function declarations. Variables declared with var are initialized with undefined, while let and const are not initialized.

2. Execution Phase:
   - The JavaScript engine executes the code line by line.
   - It assigns values to variables and executes functions as they are called.

// Example of global execution context
var x = 10;
let y = 20;
function greet() {
    console.log("Hello!");
}

greet(); // "Hello!"

// Understanding the global execution context helps in managing variable scope and avoiding conflicts in JavaScript code.   
##### function execution context

When a function is called, a new function execution context is created. It also consists of two phases: the creation phase and the execution phase.

1. Creation Phase:
   - The JavaScript engine creates a new variable object for the function.
   - It creates the 'this' keyword, which refers to the object that called the function (or undefined in strict mode).
   - It allocates memory for parameters and variables declared with var, let, const, and function declarations within the function. Parameters are initialized with the values passed to the function, variables declared with var are initialized with undefined, while let and const are not initialized.

2. Execution Phase:
   - The JavaScript engine executes the code within the function line by line.
   - It assigns values to parameters and variables as they are encountered in the code.

// Example of function execution context
function add(a, b) {
    cosole.log(arguments); // [5, 10] not array, but array like object
    var sum = a + b;
    return sum;
}

let result = add(5, 10);
console.log(result); // 15

##### closures in JS 
##### create a function that will return a function which can be called only once 
##### what happens is child function saves reference to variables of parent, meaning their changes are sustained
 
