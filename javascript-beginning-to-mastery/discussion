# preincrement, post increment 
# typeof object , .length 
# string/array[0] 
# string/array[string/array.length - 1]
# string + number ===> string... 

# string to number => Number(string) , parseInt(string) , parseFloat(string)
# number to string => String(number) , number.toString()
# boolean to number => Number(boolean)

# alert, prompt, console.log, console.error, console.warn 

# template literals => `${variable} text ${expression}`

# methods on string 
# .toUpperCase() , .toLowerCase() , .trim() , .includes(pattern) 
# .startsWith() , .endsWith() , .slice() , .substring() , .replace(patter, new pattern) (single time replacement), .repeat()
####### replace -- check it. 

# methods chaining string_var.toUpperCase().trim().slice(0,5)
# remember string is immutable, so methods return new string 


# methods on array
# .push(element) , .pop() , .shift() , .unshift(element) ------ add/remove from end/start
# .includes(element) , .indexOf(element) , .lastIndexOf(element)
# .slice(startIndex, endIndex) , .splice(startIndex, deleteCount, add_item1, add_item2, ...)
# .join(separator) , .reverse() , .concat(array2)
# .forEach( (element, index) => { ... } ) , .map( (element, index) => { ... return newElement } ) 
# .filter( (element, index) => { ... return true/false } ) , .reduce( (accumulator, element) => { ... return newAccumulator } , initialValue )
# remember array is mutable, so methods modify the original array (except slice, join, concat, map, filter, reduce)


######### implicit type convertion ----- discuss 
######### null , undefined --- discuss

# some math methods
# Math.round(number) , Math.floor(number) , Math.ceil(number) , Math.abs(number) , Math.pow(base, exponent) , Math.sqrt(number) 
# Math.min(a, b, c, ...) , Math.max(a, b, c, ...) , Math.random()
# Math.random() * (max - min) + min  => random number between min and max


# object basics
# object creation => let obj = { key1: value1, key2: value2, ... }
# accessing properties => obj.key1 , obj['key2']
# adding/updating properties => obj.key3 = value3 , obj['key4'] = value4
# deleting properties => delete obj.key1 , delete obj['key2']
# checking property existence => 'key1' in obj , obj.hasOwnProperty('key2')
# iterating over properties => for (let key in obj) { ... } 


# scope basics
# global scope , function scope , block scope (let, const)
# variable shadowing
# happens when a variable declared within a certain scope (local scope) has the same name as a variable declared in an outer scope (global scope or parent function scope).
# In such cases, the local variable "shadows" or overrides the outer variable within its own scope.
# lexical scope
# nested functions and access to outer function variables
# hoisting (var vs let/const)
# var declarations are hoisted to the top of their enclosing function or global scope. This means that you can use a var-declared variable before its actual declaration in the code.
# let and const declarations are also hoisted, but they are not initialized until their actual declaration is evaluated. This means that if you try to access a let or const variable before its declaration, you will get a ReferenceError.
##### if we declare variable using var inside a function, it's function scoped
##### now if we call that function twice, then will it retain the value from previous call or it will be re-initialized
##### answer is re-initialized. because each function call creates a new execution context with its own set of local variables.
# closures (basic idea)
# A closure is a function that "remembers" its outer variables and can access them.
# This happens because when a function is defined, it captures the surrounding lexical scope, allowing it to access variables from that scope even when the function is executed outside of it.


# function basics
# function declaration => function funcName(params) { ... }
# function expression => let funcName = function(params) { ... }
# arrow function => let funcName = (params) => { ... }
# parameters vs arguments
# default parameters => function funcName(param1 = defaultValue1, param2 = defaultValue2) { ... }
# return statement
# early return vs late return --- discuss
# happens when a function exits and returns a value to the caller.
# # Early return refers to returning a value from a function before reaching the end of the function body, often based on a condition.
# # Late return, on the other hand, refers to returning a value at the end of the function body after all the code has been executed.
# function scope and variable shadowing
# first-class functions (functions as arguments, return values)
# IIFE (Immediately Invoked Function Expression) => (function() { ... })();


# methods
# functions as object properties
# let obj = {
#   methodName: function(params) { ... }
# }
# shorthand syntax
# let obj = {
#   methodName(params) { ... }
# }
# accessing object properties using 'this' keyword
# let obj = {
#   property: value,
#   method() {
#     console.log(this.property);
#   }
# }
# 'this' refers to the object that the method is called on.
# 'this' behavior in regular functions vs arrow functions
# In regular functions, 'this' refers to the object that the function is called on.
# In arrow functions, 'this' is lexically bound to the surrounding scope where the arrow function is defined.


## can we write arrow function as method inside object ? what will be the 'this' behavior in that case ? discuss.
# Yes, we can write an arrow function as a method inside an object. However, the 'this' behavior in that case will be different from regular functions.
# In an arrow function, 'this' is lexically bound to the surrounding scope where the arrow function is defined, rather than the object itself.
# This means that if you use an arrow function as a method inside an object, 'this' will not refer to the object, but rather to the outer scope where the arrow function was defined.


# try catch block
# try { ... } catch(error) { ... } finally { ... }
# error object
# properties: name, message, stack  


# arrow function 
# const mul = (a,b) => a*b;
# implicit return
# single parameter without parenthesis
# const square = x => x * x;
# multi-line arrow function with explicit return
# const add = (a, b) => {
#   const sum = a + b;
#   return sum;
# };

# spread operator (...)
# array expansion
# const arr1 = [1, 2, 3];
# const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]
# object expansion
# const obj1 = { a: 1, b: 2 };
# const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }
# rest parameters
# function sum(...numbers) {
#   return numbers.reduce((acc, num) => acc + num, 0);
# }
# const total = sum(1, 2, 3, 4); // 10 
# destructuring
# array destructuring
# const arr = [1, 2, 3];
# const [a, b, c] = arr; // a=1, b=2, c=3
# object destructuring
# const obj = { x: 10, y: 20 };
# const { x, y } = obj; // x=10, y=20 
# default values in destructuring
# const [p = 5, q = 10] = [1]; // p=1, q=10
# const { m = 15, n = 25 } = { m: 30 }; // m=30, n=25
# modules (import/export) -- discuss




##### iterables and array like objects 

iterables are objects that can be iterated over, such as arrays, strings, maps, sets etc.
we can use for...of loop to iterate over iterables

let str = "hello";
for(let char of str){
    console.log(char);
}

array like objects are objects that have length property and indexed elements, such as arguments object, NodeList etc.
we can convert array like objects to arrays using Array.from() or spread operator

function myFunc(){
    let argsArray = Array.from(arguments);
    // or let argsArray = [...arguments];
    console.log(argsArray);
}
myFunc(1,2,3); // [1,2,3]

##### sets in JS
sets are collections of unique values, they can store any type of values, whether primitive or reference types.
we can create a set using new Set() and add values using add() method.

let mySet = new Set();
mySet.add(1);
mySet.add(2);
mySet.add(2); // duplicate value, won't be added
console.log(mySet); // Set {1,2}

we can check if a value exists in set using has() method
console.log(mySet.has(1)); // true
console.log(mySet.has(3)); // false

we can delete a value from set using delete() method
mySet.delete(1);
console.log(mySet); // Set {2}

we can get size of set using size property
console.log(mySet.size); // 1

we can iterate over set using for...of loop
for(let value of mySet){
    console.log(value);
} // 2

we can convert set to array using Array.from() or spread operator
let myArray = Array.from(mySet);
// or let myArray = [...mySet];
console.log(myArray); // [2]


## object in JS 

Objects are collections of key-value pairs, where keys are strings (or symbols) and values can be any type of data,
including other objects or functions.

let person = {
    name: "John",
    age: 30,
    isStudent: false,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

we can access object properties using dot notation or bracket notation
console.log(person.name); // John
console.log(person["age"]); // 30

we can add new properties to object
person.gender = "male";      
person["country"] = "USA";

we can delete properties from object
delete person.isStudent;

we can iterate over object properties using for...in loop
for(let key in person){
    console.log(key + ": " + person[key]);
}

we can get array of object keys using Object.keys()
let keys = Object.keys(person);
console.log(keys); // ["name", "age", "greet", "gender", "country"]

we can get array of object values using Object.values()
let values = Object.values(person);
console.log(values); // ["John", 30, function() { ... }, "male", "USA"] 

we can get array of object entries using Object.entries()
let entries = Object.entries(person);   
console.log(entries); // [["name", "John"], ["age", 30], ["greet", function() { ... }], ["gender", "male"], ["country", "USA"]]


###### map in JS

Maps are collections of key-value pairs, where keys can be of any type, including objects or functions.

let myMap = new Map();
myMap.set("name", "John");
myMap.set(1, "one");
myMap.set(true, "boolean true");

we can get value from map using get() method
console.log(myMap.get("name")); // John
console.log(myMap.get(1)); // one

we can check if a key exists in map using has() method
console.log(myMap.has(true)); // true
console.log(myMap.has(false)); // false

we can delete a key-value pair from map using delete() method
myMap.delete(1);
console.log(myMap.has(1)); // false

we can get size of map using size property
console.log(myMap.size); // 2

we can iterate over map using for...of loop
for(let [key, value] of myMap){
    console.log(key + ": " + value);
} // name: John, true: boolean true

we can convert map to array using Array.from() or spread operator
let myArray = Array.from(myMap);
// or let myArray = [...myMap];
console.log(myArray); // [["name", "John"], [true, "boolean true"]]

**** for in vs for of
for...in loop is used to iterate over object properties, it gives keys of the object.
for...of loop is used to iterate over iterable objects like arrays, strings, maps, sets etc., it gives values of the iterable.


#### cloning object 

let original = { a: 1, b: 2, c: 3 };

// spread operator
let clone = { ...original };

// using Object.assign()
let clone1 = Object.assign({}, original);

// using spread operator
let clone2 = { ...original };

// both clone1 and clone2 are shallow copies of original object

##### deep cloning object

let original = { a: 1, b: { c: 2 } };

// using JSON methods
let deepClone1 = JSON.parse(JSON.stringify(original));

// using structuredClone (modern browsers)
let deepClone2 = structuredClone(original);

// both deepClone1 and deepClone2 are deep copies of original object    

#### option chaining in JS

let user = {
    name: "John",
    address: {
        city: "New York",
        zip: "10001"
    }
};

// accessing nested property safely using optional chaining
let city = user.address?.city;
console.log(city); // New York

// accessing non-existing nested property
let country = user.address?.country;
console.log(country); // undefined

// calling method safely using optional chaining
let greet = user.greet?.();
console.log(greet); // undefined

// accessing deeply nested property safely
let zip = user.address?.zip?.code;
console.log(zip); // undefined

// optional chaining prevents runtime errors when accessing properties or methods of undefined or null values.

##### methods in objects

let calculator = {
    add: function(a, b) {
        return a + b;
    },
    subtract: function(a, b) {
        return a - b;
    },
    multiply: function(a, b) {
        return a * b;
    },
    divide: function(a, b) {
        if(b !== 0) {
            return a / b;
        } else {
            return "Cannot divide by zero";
        }
    }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
console.log(calculator.multiply(5, 3)); // 15
console.log(calculator.divide(5, 0)); // Cannot divide by zero

##### ways to create methods 
let obj = {
    // method shorthand
    greet() {
        console.log("Hello!");
    },
    // arrow function (not recommended for methods)
    farewell: () => {
        console.log("Goodbye!");
    }
};

obj.greet(); // Hello!
obj.farewell(); // Goodbye!

##### this keyword, how it works in methods

let person = {
    name: "John",
    greet: function() {
        console.log("Hello, my name is " + this.name);
    },
    farewell: () => {
        console.log("Goodbye from " + this.name);
    }
};

person.greet(); // Hello, my name is John
person.farewell(); // Goodbye from undefined

// in greet method, this refers to person object
// in farewell method, this refers to global object (window in browsers), hence undefined

##### binding this keyword

let person = {
    name: "John",
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

let greetFunction = person.greet;
greetFunction(); // Hello, my name is undefined

// binding this to person object
let boundGreet = greetFunction.bind(person);
boundGreet(); // Hello, my name is John

when we create function inside object, this refers to that object 
function kind of binds to that object 

this is what happens on variables, that's why they hoists 
as calling function inside object, this refers to that object only...
and that object has those variables at that time...

function defined using  function  keyword binds this to that object
this can be avoided using strict mode 
function func() {
    "use strict";
    console.log(this); // undefined
}

##### call, apply and bind methods

let person1 = {
    name: "John",
    greet: function(greeting) {
        console.log(greeting + ", my name is " + this.name);
    }
};

let person2 = {
    name: "Jane"
};

// using call
person1.greet.call(person2, "Hello"); // Hello, my name is Jane

// using apply
person1.greet.apply(person2, ["Hi"]); // Hi, my name is Jane

// using bind
let boundGreet = person1.greet.bind(person2, "Hey");
boundGreet(); // Hey, my name is Jane

// call and apply invoke the function immediately with specified this value and arguments
// bind returns a new function with specified this value and arguments, which can be invoked later


###### towards object oriented programming

#### why needed 
let's say we have to create multiple objects with same properties and methods

let person1 = {
    name: "John",
    age: 30,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

let person2 = {
    name: "Jane",
    age: 25,
    greet: function() {
        console.log("Hello, my name is " + this.name);
    }
};

// this approach is not scalable and leads to code duplication

#### constructor functions

function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        console.log("Hello, my name is " + this.name);
    };
}

let person1 = new Person("John", 30);
let person2 = new Person("Jane", 25);

person1.greet(); // Hello, my name is John
person2.greet(); // Hello, my name is Jane

// constructor functions allow us to create multiple objects with same structure

#### prototypes

function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log("Hello, my name is " + this.name);
};

let person1 = new Person("John", 30);
let person2 = new Person("Jane", 25);

// what and why is prototype in function object 
person1.greet(); // Hello, my name is John ---- new automatically links __proto__ to Person.prototype
person2.greet(); // Hello, my name is Jane

// prototypes allow us to share methods among all instances of an object

#### 3nd problem with constructor functions is that they are not very intuitive and can lead to confusion with this keyword.
#### if we want to create a class with inheritance, we need to use __proto__ which is not recommended.
// let's see how it happens
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(this.name + " makes a noise.");
};

function Dog(name) {
    Animal.call(this, name); // call super constructor
}
Dog.prototype = Object.create(Animal.prototype); // inherit from Animal
Dog.prototype.constructor = Dog;
Dog.prototype.speak = function() {
    console.log(this.name + " barks.");
};

let dog = new Dog("Buddy");
dog.speak(); // Buddy barks.

// this approach is cumbersome and not very readable

#### object inheritence 
let animal = {
    speak: function() {
        console.log(this.name + " makes a noise.");
    }
};

let dog = Object.create(animal); // sets animal as prototype of dog __proto__
dog.name = "Buddy";
dog.speak(); // Buddy makes a noise.

// this approach is cumbersome and not very readable

#### classes solving these issues.... 

default way was 

function createUser(name, age) {
    const user = Object.create(createUser.prototype);
    user.name = name;
    user.age = age;
    return user;
}
createUser.prototype.greet = function() {
    console.log("Hello, my name is " + this.name);
};
// now using class
// convension to start class name with capital letter, and this is need New keyword to create object
// constructor function is special function that is called when new object is created
// they also follow this convension.
class User {
    constructor(name, age) {
        /// this creates empty object and passes as this.
        /// using new keyword here makes this = Object.create(User.prototype)
        this.name = name;
        this.age = age;
        // automatically returns this
    }
    greet() {
        console.log("Hello, my name is " + this.name);
    }
}

### iterating keys over objet created by constructor function gives keys of prototype also
let user1 = new User("John", 30);
for(let key in user1) {
    console.log(key); // name, age, greet
}
### to avoid this we can use hasOwnProperty method
for(let key in user1) {
    if(user1.hasOwnProperty(key)) {
        console.log(key); // name, age
    }
}

##### getting prototype of object

let proto = Object.getPrototypeOf(user1);

##### inheritance in classes

class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(this.name + " makes a noise.");
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name); // call super class constructor
    }
    speak() {
        console.log(this.name + " barks.");
    }
}

let dog = new Dog("Buddy");
dog.speak(); // Buddy barks.

##### getters and setters in classes

class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    get area() {
        return this.width * this.height;
    }
    set area(value) {
        this.width = Math.sqrt(value);
        this.height = Math.sqrt(value);
    }
}

let rect = new Rectangle(4, 5);
console.log(rect.area); // 20

rect.area = 36;
console.log(rect.width); // 6
console.log(rect.height); // 6

// getters and setters allow us to define computed properties and control access to object properties

##### how javascript engine works

JavaScript engine is a program that executes JavaScript code. It consists of several components that work together to parse, compile, and execute the code.

1. Parser: The parser reads the JavaScript code and converts it into an Abstract Syntax Tree (AST). The AST is a tree-like structure that represents the syntactic structure of the code.

2. Compiler: The compiler takes the AST and converts it into bytecode or machine code that can be executed by the JavaScript engine. Modern JavaScript engines use Just-In-Time (JIT) compilation to optimize the code during runtime.
    for early error checking and determining appropriate scope for variables.

3. Execution Context: The execution context is the environment in which the JavaScript code is executed. It consists of the variable object, scope chain, and this value. Each time a function is called, a new execution context is created.

4. Call Stack: The call stack is a data structure that keeps track of the execution context of functions. When a function is called, its execution context is pushed onto the call stack. When the function returns, its execution context is popped off the stack.

5. Memory Heap: The memory heap is a region of memory where objects and variables are stored. The JavaScript engine manages memory allocation and garbage collection to free up memory that is no longer needed.

6. Event Loop: The event loop is responsible for handling asynchronous operations in JavaScript. It continuously checks the call stack and the task queue for any pending tasks and executes them when the call stack is empty.`

#### hoisting in JS

js already knows which variable has what scope before executing code ( during compilation)
so it allocates memory for variables and functions before executing code.

1. Variable Hoisting:
   - Variables declared with var are hoisted to the top of their function scope and initialized with undefined.
   - Variables declared with let and const are hoisted to the top of their block scope but are not initialized. Accessing them before declaration results in a ReferenceError.

2. Function Hoisting:
   - Function declarations are hoisted to the top of their scope and can be called before they are defined.
   - Function expressions (including arrow functions) assigned to variables are not hoisted. Accessing them before declaration results in a ReferenceError.

// Example of variable hoisting
console.log(x); // undefined
var x = 5;

console.log(y); // ReferenceError: Cannot access 'y' before initialization, in global execution context they are uninitialized. 
// they are present in memory but uninitialized.
// time period between creation phase and execution phase is called temporal dead zone
// meaning till variable is initialized, it is in dead zone
// if it was not present in memory, then it would be ReferenceError: x is not defined
typeof y; // ReferenceError: Cannot access 'y' before initialization
but if it's not initatilized even after this phase, then typeof gives undefined
let y = 10;

// Example of function hoisting
greet(); // "Hello!"
function greet() {
    console.log("Hello!");
}

farewell(); // TypeError: farewell is not a function
var farewell = function() {
    console.log("Goodbye!");
};

// Understanding hoisting helps avoid unexpected behaviors in JavaScript code.

##### scope chain in JS

Scope chain is the hierarchy of scopes that determines the accessibility of variables and functions in JavaScript. When a variable or function is referenced, the JavaScript engine looks for it in the current scope and then moves up the scope chain until it finds the reference or reaches the global scope.

1. Global Scope: Variables and functions declared outside of any function or block are in the global scope and can be accessed from anywhere in the code.

2. Function Scope: Each function creates a new scope. Variables and functions declared within a function are only accessible within that function and its nested functions.

3. Block Scope: Variables declared with let and const within a block (e.g., if, for, while) are only accessible within that block.

###### global execution context

When a JavaScript program starts executing, the global execution context is created. It consists of two phases: the creation phase and the execution phase.

1. Creation Phase:
   - The JavaScript engine creates the global object (window in browsers, global in Node.js).
   - It creates the 'this' keyword, which refers to the global object.
   - It allocates memory for variables and functions declared with var, let, const, and function declarations. Variables declared with var are initialized with undefined, while let and const are not initialized.

2. Execution Phase:
   - The JavaScript engine executes the code line by line.
   - It assigns values to variables and executes functions as they are called.

// Example of global execution context
var x = 10;
let y = 20;
function greet() {
    console.log("Hello!");
}

greet(); // "Hello!"

// Understanding the global execution context helps in managing variable scope and avoiding conflicts in JavaScript code.   
##### function execution context

When a function is called, a new function execution context is created. It also consists of two phases: the creation phase and the execution phase.

1. Creation Phase:
   - The JavaScript engine creates a new variable object for the function.
   - It creates the 'this' keyword, which refers to the object that called the function (or undefined in strict mode).
   - It allocates memory for parameters and variables declared with var, let, const, and function declarations within the function. Parameters are initialized with the values passed to the function, variables declared with var are initialized with undefined, while let and const are not initialized.

2. Execution Phase:
   - The JavaScript engine executes the code within the function line by line.
   - It assigns values to parameters and variables as they are encountered in the code.

// Example of function execution context
function add(a, b) {
    cosole.log(arguments); // [5, 10] not array, but array like object , indexed access and length property
    var sum = a + b;
    return sum;
}

let result = add(5, 10);
console.log(result); // 15

## lexical scope vs dynamic scope
Lexical Scope:
Lexical scope, also known as static scope, is determined by the structure of the code and the location of variable declarations.
In lexical scope, a function can access variables from its own scope and from the scopes of its parent functions,
based on where the function is defined in the code.  

Dynamic Scope:
Dynamic scope is determined by the call stack and the order in which functions are called at runtime.
In dynamic scope, a function can access variables from its own scope and from the scopes of functions that are currently on the call stack,
regardless of where the function was defined in the code.




##### closures in JS 
##### create a function that will return a function which can be called only once 
##### what happens is child function saves reference to variables of parent, meaning their changes are sustained


function printX(x) {
    return function() {
        console.log(x);
    };
}

let printFive = printX(5);
printFive(); // 5 

##### private variables using closures
function Counter() {
    let count = 0; // private variable

    this.increment = function() {
        count++;
        return count;
    };

    this.decrement = function() {
        count--;
        return count;
    };

    this.getCount = function() {
        return count;
    };
}

let counter = new Counter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount()); // 1


##### module pattern using closures
let CounterModule = (function() {
    let count = 0; // private variable
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
})();

console.log(CounterModule.increment()); // 1
console.log(CounterModule.increment()); // 2
console.log(CounterModule.decrement()); // 1
console.log(CounterModule.getCount()); // 1


##### currying in JS using closures
Currying is a technique in functional
programming where a function with multiple arguments is transformed into a sequence of functions, each taking a single argument.

function add(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

let result = add(1)(2)(3);
console.log(result); // 6

##### memoization in JS using closures
Memoization is an optimization technique used to speed up 
function calls by caching the results of expensive function calls and returning the cached result when the same inputs occur again.

function memoize(fn) {
    const cache = {};
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache[key]) {
            return cache[key];
        } else {
            const result = fn(...args);
            cache[key] = result;
            return result;
        }
    };
}

function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(40)); // 102334155
console.log(memoizedFibonacci(41)); // 165580141


###### deep dive how closers work in JS, why closures are created, how they retain reference to outer variables
Closures are created in JavaScript when a function is defined inside another function,
allowing the inner function to access variables from the outer function's scope even after the outer function has finished executing.

function outerFunction() {
    let outerVariable = "I am from outer function";

    function innerFunction() {
        console.log(outerVariable);
    }

    return innerFunction;
}

let closureFunction = outerFunction();
closureFunction(); // "I am from outer function"
// In this example, innerFunction forms a closure that retains access to outerVariable
// even after outerFunction has completed execution. This is because the inner function
// maintains a reference to the outer function's scope, allowing it to access its variables.


can memory leak happen due to closures ?
Yes, memory leaks can occur due to closures in JavaScript.
When a closure retains references to variables from its outer scope, those variables cannot be garbage collected
as long as the closure exists. If the closure is kept alive longer than necessary, it can lead to increased memory usage and potential memory leaks.
To avoid memory leaks caused by closures, it's important to ensure that closures are not retained longer than needed,
and to nullify references to outer variables when they are no longer required.

will closures retain updated value of outer variables or the value at the time of closure creation ?
Closures in JavaScript retain references to the outer variables, not their values at the time of closure creation.
This means that if the outer variable is updated after the closure is created, the closure will reflect the updated value when it is accessed.

that means closures always retain the current value of outer variables, not a snapshot of their values at the time of closure creation.



function func() {
    let counter = 0;
    return function() {
        counter++;
        console.log(counter);
    };
}

let incrementCounter = func();
let incrementCounter2 = func();

### both function will be having their own separate closure with their own counter variable


####### DOM manipulation using JS

##### what is DOM
The Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects,
allowing programming languages like JavaScript to manipulate the content, structure, and style of web pages dynamically.
window.document is the root of the DOM tree, representing the entire HTML document.
console.dir(window.document) shows the properties and methods of the document object.
console.log(window.document) shows the HTML structure of the document.

##### selecting elements in DOM
// Selecting by ID
let elementById = document.getElementById("myId");

// Selecting by Class Name
let elementsByClass = document.getElementsByClassName("myClass");

// Selecting by Tag Name
let elementsByTag = document.getElementsByTagName("div");

#### get ElementsByClassName and getElementsByTagName return live HTMLCollections [[ TODO ]]
// meaning they automatically update when the DOM changes.
// while getElementById returns a static reference to the element.


// Selecting using Query Selector
let firstElement = document.querySelector(".myClass");
let allElements = document.querySelectorAll(".myClass");

##### manipulating elements in DOM
// Changing text content
elementById.textContent = "New Text";

// Changing HTML content
elementById.innerHTML = "<strong>Bold Text</strong>";
textContent property represents the text content of an element and its descendants.
innerHTML property represents the HTML content of an element as a string, including any child elements and HTML tags.

innerText is similar to textContent, but it takes into account the CSS styles applied to the element, such as visibility and display properties.
innerText returns the visible text content of an element, while textContent returns all text content, regardless of visibility.

##################### traversing DOM ##################################


// Accessing parent element
let parentElement = elementById.parentNode;
// Accessing child elements
let childElements = elementById.children;
// getting child nodes (including text nodes)
let childNodes = elementById.childNodes;
// Accessing sibling elements
let nextSibling = elementById.nextElementSibling;
let previousSibling = elementById.previousElementSibling;


#### text node vs element node
In the DOM, there are different types of nodes that represent different parts of the document. Two common types are:
1. Element nodes: Represent HTML elements like <div>, <p>, etc.
2. Text nodes: Represent the text content within an element.
For example, in the HTML <p>Hello World</p>, the <p> tag is an element node, and "Hello World" is a text node that is a child of the <p> element node.

<!DOCTYPE html>
<html>
  <head>
    <title>My Page</title>
  </head>
  <body>
    <h1>Hello World</h1>
    <p>This is a <strong>simple</strong> page.</p>
  </body>
</html>


## create a sample default tree showing head doesn't take left/right text node but others does
Document
│
├── <!DOCTYPE html>
│
└── html  (Element Node)
    │
    ├── head  (Element Node)
    │   │
    │   └── title  (Element Node)
    │       │
    │       └── "My Page"  (Text Node)
    │
    └── body  (Element Node)
        │
        ├── h1  (Element Node)
        │   │
        │   └── "Hello World"  (Text Node)
        │
        └── p  (Element Node)
            │
            ├── "This is a "  (Text Node)
            │
            ├── strong  (Element Node)
            │   │
            │   └── "simple"  (Text Node)
            │
            └── " page."  (Text Node)


// Changing styles
elementById.style.color = "red";
elementById.style.fontSize = "20px";

##### style properties can be accessed using camelCase notation
// e.g., background-color becomes backgroundColor n

// Adding a class
elementById.classList.add("newClass");

// Removing a class
elementById.classList.remove("myClass");

// check if class present
console.log(elementById.classList.contains("myClass")); // false

// Toggling a class
elementById.classList.toggle("activeClass");

// getting and setting attributes
// Getting an attribute
let attrValue = elementById.getAttribute("data-custom");
// Setting an attribute
elementById.setAttribute("data-custom", "newValue");

##### when and when not to use innerHTML to add new element
Using innerHTML to add new elements can be convenient, but it has some drawbacks and potential security risks. Here are some guidelines on when to use innerHTML and when to avoid it:

When to use innerHTML:
1. When you need to add a large block of HTML content at once,
and you are sure that the content is safe and does not contain any user-generated input
that could lead to XSS vulnerabilities.
2. When you want to quickly update the entire content of an element without
needing to manipulate individual child elements.    

When to avoid innerHTML:
1. When you need to add or manipulate individual elements within an existing structure,
as using innerHTML will replace the entire content of the element, which can lead to loss of event
listeners and other state associated with the existing elements.
2. When you are dealing with user-generated content or any content that could potentially
contain malicious code, as using innerHTML can expose your application to Cross-Site Scripting (XSS) attacks
if the content is not properly sanitized.
3. When you want to maintain the existing structure and state of the DOM,
as using innerHTML will remove all existing child nodes

##### creating and removing elements in DOM
// Creating a new element
let newElement = document.createElement("p");
newElement.textContent = "This is a new paragraph.";

// Appending the new element to the body
document.body.appendChild(newElement);  
prependChild()
## will this new element be added at the end of body ? yes it will be added at the end of body

// Removing an element
let elementToRemove = document.getElementById("removeMe");
elementToRemove.parentNode.removeChild(elementToRemove);

##### order of child matters in DOM, how'd we add as sibling, or child in middle
let referenceElement = document.getElementById("reference");
let newElement = document.createElement("p");
newElement.textContent = "Inserted before reference element.";
referenceElement.parentNode.insertBefore(newElement, referenceElement); // insert before reference element

// insert after reference element
referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);

// replacing an element in DOM
replaceChild() can be used to replace an existing child element with a new element
let newElement = document.createElement("p");
newElement.textContent = "This is a replacement paragraph.";
let parentElement = document.getElementById("parent");
let oldElement = document.getElementById("oldChild");
parentElement.replaceChild(newElement, oldElement); // replace oldChild with newElement

// insert adjacent HTML 
referenceElement.insertAdjacentHTML("beforebegin", "<p>Inserted before reference element.</p>");
referenceElement.insertAdjacentHTML("afterend", "<p>Inserted after reference element.</p>");

// clone nodes 
let clonedElement = referenceElement.cloneNode(true); // true for deep clone
referenceElement.parentNode.insertBefore(clonedElement, referenceElement.nextSibling); // insert cloned element

// getting dimensions of element
let element = document.getElementById("myElement");
let width = element.offsetWidth;
let height = element.offsetHeight;

invo = element.getBoundingClientRect(); // gives size and position of element relative to viewport
console.log(invo.top, invo.left, invo.width, invo.height);


##### event handling in DOM ##########################

// click element directly into HTML
<button onclick="alert('Button clicked!')">Click Me</button>
 
// Adding an event listener
let button = document.getElementById("myButton");
button.addEventListener("click", function() {
    alert("Button clicked!");
});

### how event listners work in JS, how they are stored, how they are executed when event occurs
When an event occurs on an element, the JavaScript engine checks if there are any event listeners attached to that element 
for the specific event type. If there are, it executes the callback functions associated with those event
listeners in the order they were added.
Event listeners are stored in an internal data structure within the JavaScript engine,
typically as part of the element's properties.
When an event is triggered, the engine retrieves the relevant event listeners and executes them with
the appropriate context (the element that triggered the event) and any event-specific data (like event object).

So how this works is when we add event listener using addEventListener, 
t adds the callback function to the list of event listeners for that element and event type.
When the event occurs, the engine iterates through the list of event listeners and executes each callback function in order.  

so this keyword inside the event listener callback function refers to the element that triggered the event,
allowing us to access its properties and methods.

// Removing an event listener
function handleClick() {
    alert("Button clicked!");
}
button.addEventListener("click", handleClick);
button.removeEventListener("click", handleClick);

## key press event
let input = document.getElementById("myInput");
input.addEventListener("keypress", function(event) {
    console.log("Key pressed: " + event.key);
});

## mouse hover event
let hoverElement = document.getElementById("hoverElement");
hoverElement.addEventListener("mouseover", function() {
    console.log("Mouse over element!");
});
hoverElement.addEventListener("mouseout", function() {
    console.log("Mouse out of element!");
});


##### event object
When an event occurs, the event listener callback function receives an event object as an argument.
This event object contains information about the event, such as the type of event, the target element,
and any additional data related to the event.
For example, in a click event listener,
the event object will contain properties like event.type ("click"),
event.target (the element that was clicked),
and event.clientX/event.clientY (the coordinates of the mouse pointer when the event occurred).

e.target ====> gives the element that triggered the event,
while this keyword inside the event listener callback function also refers to the element that triggered the event.
However, if we use an arrow function as the event listener callback,
this will not refer to the element that triggered the event, but will instead refer to the lexical scope
in which the arrow function was defined. In such cases,
we should use the event object to access the target element using e.target.

##### internal working
browsers webAPI's keeps all callbacks which are to be triggered when event occurs
when browser detects an event, it checks the list of callbacks for that event type and executes them in order.
it pushes them in a queue and when call stack is empty, it pops the callbacks from the queue and executes them.
Event loop continuously checks the call stack and the event queue, and processes events as they occur.


#### event bubbling, capturing and delegation
Event bubbling is a mechanism in which an event starts from the target element and
    propagates up through its ancestors in the DOM tree until it reaches the root element. This means that if you click
    on a child element, the click event will first trigger on that child element and then bubble up to its parent elements.
Event capturing, on the other hand, is the opposite of event bubbling. In event capturing, the event starts from the root
    element and propagates down through the ancestors until it reaches the target element. This means that if you click on a child element, the click event will first trigger on the root element and then capture down to the child element.
Event delegation is a technique that takes advantage of event bubbling to handle events at a higher level in the DOM tree.
    Instead of attaching event listeners to individual child elements, you can attach a single event listener to a parent
    element and use event delegation to handle events for its child elements. This can improve performance and reduce memory
    usage, especially when dealing with a large number of child elements.


what is difference in use of bubbling and capturing in event handling ?
Event bubbling is the default behavior in JavaScript, and it is generally more commonly used than event capturing.
However, there are certain scenarios where event capturing can be useful:
1. When you want to handle events at a higher level in the DOM tree before they reach the target element,
such as for implementing global event handlers or for handling events on dynamically added elements.
2. When you want to prevent certain events from reaching the target element, such as for implementing custom event
handling logic or for preventing default behavior on certain elements.
3. When you want to handle events in a specific order, such as for implementing complex interactions
between elements that require a specific sequence of event handling.   

if we capture some event on parent, and click on child, will it trigger both capturing and bubbling event listeners ? 
    yes it will trigger both capturing and bubbling event listeners, but capturing event listeners will be triggered first,
    followed by bubbling event listeners.
but then how can we prevent events from reaching target element if we are using capturing ? 
    we can use event.stopPropagation() method to stop the event from propagating further down the DOM tree,
    preventing it from reaching the target element and triggering any event listeners attached to it.


##### including external JS file in HTML
<script src="path/to/your/script.js"></script>
this is sync JS synchronous loading of JS file --- executed when encountered

<script async src="path/to/your/script.js"></script>
this is async JS asynchronous loading of JS file --- executed whenever it is loaded

<script defer src="path/to/your/script.js"></script>
this is defer JS defer loading of JS file --- executed after HTML is parsed

##### important notes 
querySelector can be used to select any element using CSS selectors, while getElementById, getElementsByClassName, and getElementsByTagName are specific to selecting elements by ID, class, and tag name respectively.
getElementById returns a single element, while getElementsByClassName and getElementsByTagName return live HTMLCollections, which are array-like objects that automatically update when the DOM changes.
textContent returns the text content of an element and its descendants, while innerHTML returns the HTML content of an element as a string, including any child elements and HTML tags.

querySelector and querySelectorAll return static NodeLists,
which do not update when the DOM changes, while getElementsByClassName and getElementsByTagName return live HTMLCollections that do update when the DOM changes.

# Important # querySelector can be used on any HTML element
meaning using it on some element will search for the first matching element within that element's subtree, while using it on document will search the entire document.






##### asynchronous programming in JS

in synchronous, next line is not executed without completion of previous line
JS is synchronous... and single threaded..

## let's understand setTimeout( function, time in mili seconds )
this is function provided by web browser 
web API's takes callback function and add's to callback queue after 1 seconds
and when JS finds calls tack empty event loop takes function to execute.

so JS won't wait for 1 second, instead this is done by webAPI for us, JS moves forward.

Remember : call stack has Global Execution context, meaning function from call stack taken after GEC done.

let id = setTimeout(()=>console.log("working),1000)
clearTimeout(id);


#### function with callback for success and onError
let's say we need to perform some task or some checks if pass then call success
otherwise call onError.

function getTwoNumbersAndAdd(number1, number2, onSuccess, onFailure) {
  if (typeof number1 === "number" && typeof number2 === "number") {
    onSuccess(number1, number2);
  } else {
    onFailure();
  }
}

function addTwoNumbers(num1, num2) {
  console.log(num1 + num2);
}

function onFail(){
    console.log("Wrong data type");
    console.log("please pass numbers only")
}
getTwoNumbersAndAdd(4, 4,addTwoNumbers, onFail);


#### callbacks in asynchronous programming...

// callback hell  
// setTimeout(()=>{
//   heading1.textContent = "one";
//   heading1.style.color = "violet";
//   setTimeout(()=>{
//     heading2.textContent = "two";
//     heading2.style.color = "purple";
//     setTimeout(()=>{
//       heading3.textContent = "three";
//       heading3.style.color = "red";
//       setTimeout(()=>{
//         heading4.textContent = "four";
//         heading4.style.color = "pink";
//         setTimeout(()=>{
//           heading5.textContent = "five";
//           heading5.style.color = "green";
//         },2000)   
//       },1000)
//     },2000)
//   },2000)
// },1000)

#### let's do things using callbacks so we can stop after failure

function changeText(element, text, color, time, onSuccessCallback, onFailureCallback) {
  setTimeout(()=>{
    if(element){
      element.textContent = text;
      element.style.color = color;
      if(onSuccessCallback){
        onSuccessCallback();
      }
    }else{
      if(onFailureCallback){
        onFailureCallback();
      }
    }
  },time)
}
// pyramid of doom
changeText(heading1, "one","violet",1000,()=>{
  changeText(heading2, "two","purple",2000,()=>{
    changeText(heading3, "three","red",1000,()=>{
      changeText(heading4, "four","pink",1000,()=>{
        changeText(heading5, "five","green",2000,()=>{
          changeText(heading6, "six","blue",1000,()=>{
            changeText(heading7, "seven","brown",1000,()=>{
              changeText(heading8, "eight","cyan",1000,()=>{
                changeText(heading9, "nine","#cda562",1000,()=>{
                  changeText(heading10, "ten","dca652",1000,()=>{
                    
                  },()=>{console.log("Heading10 does not exist")})
                },()=>{console.log("Heading9 does not exist")})
              },()=>{console.log("Heading8 does not exist")})
            },()=>{console.log("Heading7 does not exist")})
          },()=>{console.log("Heading6 does not exist")})
        },()=>{console.log("Heading5 does not exist")})
      },()=>{console.log("Heading4 does not exist")})
    },()=>{console.log("Heading3 does not exist")})
  },()=>{console.log("Heading2 does not exist")})
},()=>{console.log("Heading1 does not exist")})



Promise -> has status : pending fullfilled etc.., value = value returned on success of failure.
promise takes a executible function. 

promised_value = new Promise((resolve,reject) => {
    if(condition fullfilled) {
        execute
        resolve("successful");
    } else {
        reject("failure");
    }
});

// resolve and reject takes some object which is returned while consuming....

now let's consume promise ( js developer creates less promises but consuems a lot of them)

promised_value.them((resolve_returned_value)=>{
    console.log(`returned value {resolve_value}`);
}, (reject_value) => {
    console.log(`returned value {reject_value}`);
});

###### this is similar to what we created previously....
##### but here we can have chaining....

promised_value.them((resolve_returned_value)=>{
    console.log(`returned value {resolve_value}`);
}).catch((reject_value) => {
    console.log(`returned value {reject_value}`);
})

###### let's see how promises are asynchronous task. ( promise is not JS feature instead it's a browser feature)

then,catch are only called after we have completed serial execution of script. that's why it's asynchronous.
promises are added to microtask qeueues...

***** microtask qeueue is propritised by event loop, so if both have some value first, promises will be resolved..


prmise.resolve(val) ==> returns a promise that resolves with value = val.

Promise.reslve(5).then(value => console.log(value))

## then also resolves promise, that way we can chain them...

myPromise()
    .then((value) => {
        console.log(value);
        value += "bar";
        return value; ----> internally its Promise.resolve(value);
        ---> if we don't return anything, then js will Promise.resolve(undefined);
        ---> so value will be undefined.
    })
    .then((value) {
        console.log(value);
    })

###### let's try to resolve callback hell
we don't need callbacks function as they will be taken care by then.catch.
also we need to call resolve when we are satisfied with timeout, otherwise reject 

function changeText(element, text, color, time) {
    return new Promise(resolve, reject) {
        setTimeout(()=>{
            if(element) {
                element.textColor = text;
                element.style.color = color;
                resolve();
            }
            else {
                reject();
            }
        }
    }
}

changeText(heading1, "one", red, 2000)
.then( () => changeText(heading2, 'two', blue, 3000)))
.then( () => changeText(heading3, 'three', blue, 2000)))
.catch( () => console.log(error))

## if we don't return then we'll return undefined, and timeout will go out for 3 seconds
## there is not need to wait for timeout, and then will resolve early. and then executed early.
## so next two won't work as expected.


## if any of them fails, then they'll directly goto rejrect.






######################### AJAX ##############################################
async JS and XML.


// BASIC THEORY 

// AJAX : asynchronous javascript and XML

// HTTP request

// is a set of "web development techniques" 
// using many web technologies on the "client-side "
// to create asynchronous web applications. 


// With Ajax, web applications can send and retrieve 
// data from a server asynchronously (in the background) 
// without interfering with the display and 
// behaviour of the existing page

// We don't use data in XML format anymore. 
// we use JSON now. 


// we have 3 most common ways to create and send request to server
// 1.) xmlHTTPRequest (old way of doing)
// 2.) fetch API (new way of doing)
// 3.) axios (this is third party library)


// json placeholder typicode. ::::: https://jsonplaceholder.typicode.com/
json vs js object 

json ---> key should always have a double quotes.
    --> and only supports string, number, boolean, null, object, arrays...

### xhr states : : : 
UNSENT (0): The object has been created, but open() has not been called.
OPENED (1): open() has been called, and headers can be set before send().
HEADERS_RECEIVED (2): send() has been called, and response headers are received.
LOADING (3): The response body is being received, and partial data may be available.
DONE (4): The request is complete, whether successfully or due to an error

const URL = "https://jsonplaceholder.typicode.com/posts";
const xhr = new XMLHttpRequest();
// console.log(xhr);
// step1
// console.log(xhr.readyState);
xhr.open("GET",URL);
// console.log(xhr.readyState);
// xhr.onreadystatechange = function(){
//     // console.log(xhr.readyState);
//     if(xhr.readyState === 4){
//         console.log(xhr)
//         const response = xhr.response;
//         const data = JSON.parse(response);
//         console.log(typeof data);
//     }
// }

xhr.onload = function(){
    const response = xhr.response;
    const data = JSON.parse(response);
    console.log(data);
}

xhr.send();


##### doing this using promises.  ######################

const URL = "https://jsonplaceholder.typicode.com/posts";

function sendRequest(method, url) {
    return new Promise(function(resolve, reject) {
        const xhr  = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.onload = function() {
            if(xhr.status >= 200 && xhr.status < 300){
                resolve(xhr.response);
            }
            else{
                reject(new Error("Something Went wrong"));
            }
        }

        xhr.onerror = function() {
            reject(new Error("Something went wrong"));
        }

        xhr.send();
    })
}

sendRequest("GET", URL)
    .then(response => {
        const data = JSON.parse(response);
        // console.log(data)
        return data;
    })
    .then(data=>{
        const id = data[3].id;
        return id;
    })
    .then(id=>{
        const url = `${URL}/${id}ssss`;
        return sendRequest("GET", url);
    })
    .then(newResponse => {
        const newData = JSON.parse(newResponse);
        console.log(newData);
    })
    .catch(error =>{
        console.log(error);
    })


######################### fetch API #################################
// sending data using fetch api, we write 2nd argument giving response arguments.
// getting response is done just passing URL
// remaining .then works same as both gives response and we have response status etc..
// try it with jsonplaceholder API's.


const URL = "https://jsonplaceholder.typicode.com/postssss";

fetch(URL,{
    method: 'POST',
    body: JSON.stringify({
        title: 'foo',
        body: 'bar',
        userId: 1,
    }),
    headers: {
        'Content-type': 'application/json; charset=UTF-8',
    },
    })
    .then(response =>{
        if(response.ok){
            return response.json()
        }else{
            throw new Error("Something went wrong!!!")
        }
    })
    .then(data =>{
        console.log(data);
    })
    .catch(error =>{
        console.log("inside catch");
        console.log(error);
    })



##########################3 async keyword ########################
auto creates promise object with given function as trigger.
here we can wait to make some things serial and making whole as async will return promise.


const getPosts = async() =>{
    const response = await fetch(URL);
    if(!response.ok){
        throw new Error("Something went wrong")
    }
    const data = await response.json();
    return data;
}

// const myData = getPosts();
// console.log(myData);

getPosts()
    .then((myData) => {
        console.log(myData);
    })
    .catch(error =>{
        console.log("inside catch")
        console.log(error);
    })


console.log("script end ");



######################## modules ###################

1. What is a Module?
A module is a separate JavaScript file that:
Has its own scope
Exports variables/functions/classes
Can import code from other files


Modules help with:
Code organization
Reusability
Maintainability
Avoiding global scope pollution


2. Types of JavaScript Modules
2.1 ES Modules (Modern Standard) ✅
Native in browsers
Native in Node.js (modern versions)
Uses import and export
This is what you should learn and use.


2.2 CommonJS (Older Node.js system)

Uses require() and module.exports
Still used in many Node projects

3. ES Modules (ESM)
3.1 Basic File Structure
You need:
project/
 ├── index.html
 ├── main.js
 └── utils.js

4. Exporting from a Module
4.1 Named Export
utils.js:
export function add(a, b) {
    return a + b;
}
export const PI = 3.14;

Importing:

import { add, PI } from "./utils.js";
console.log(add(2, 3));
console.log(PI);


Important:

Must use { }
Must include .js extension in browser

4.2 Default Export
utils.js:
export default function greet(name) {
    return `Hello ${name}`;
}

Importing:

import greet from "./utils.js";
console.log(greet("Raman"));


Rules:
Only ONE default export per file
No { } when importing default

4.3 Mixed Export

utils.js:
export const PI = 3.14;
export default function greet(name) {
    return `Hello ${name}`;
}


Importing:

import greet, { PI } from "./utils.js";

5. Using Modules in Browser

In HTML:

###############33 <script type="module" src="main.js"></script> ###################


Important:

Must use type="module"
Works only when served through a server (not file:// in many browsers)
You can use:

Live Server (VS Code)
Node http-server
Any local server

6. Module Scope Rules

Inside modules:

var, let, const are NOT global
this is undefined at top level
Code runs in strict mode automatically

Example:

var x = 10;
This does NOT attach to window.

7. Renaming Imports

You can rename while importing:
import { add as sum } from "./utils.js";


Now use:

sum(2, 3);

8. Import All
import * as utils from "./utils.js";

console.log(utils.add(2, 3));
console.log(utils.PI);

9. Dynamic Import (Lazy Loading)

Used when you want to load module only when needed.

button.addEventListener("click", async () => {
    const module = await import("./utils.js");
    console.log(module.add(2, 3));
});


######################### debouncing ######################################

Debouncing – Complete Crisp Notes
1. What is Debouncing?
Debouncing is a technique to limit how often a function executes.
It ensures:
Function runs only after a delay
If triggered again before delay ends → timer resets
Real Example
Search input
Window resize
Scroll events
Instead of calling API on every keystroke, wait 300ms after user stops typing.

2. Basic Debounce Implementation
function debounce(fn, delay) {
    let timer;
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}

3. What is a Decorated Function?
A decorator function:
Takes a function as input
Returns a new modified function
It "wraps" original function with extra behavior.

Example:
function decorator(fn) {
    return function () {
        console.log("Before");
        fn();
        console.log("After");
    };
}

Here:
fn → original function
Returned function → decorated function
Debounce is a decorator.

4. What is a Rest Parameter?
Syntax:
function example(...args) {
    console.log(args);
}
...args collects all arguments into an array
Allows flexible argument passing

In debounce:
return function (...args)
This ensures decorated function can accept ANY number of arguments.

5. Why Use apply(this, args)?
Problem:
When wrapping a function, we may lose original this.
Solution:
Use:
fn.apply(this, args);
Preserves this
Passes arguments array properly

Alternative:
fn.call(this, ...args);

6. What is Closure in Debounce?
Debounce works because of closure.
let timer;
timer persists between calls
Stored in outer function scope
Inner function remembers it
This allows:
Clearing previous timeout
Setting new one

7. Execution Flow
If delay = 300ms
User types:

t  → timer starts
te → timer reset
tes → timer reset
test → timer reset
(wait 300ms)
→ function runs once

8. Leading vs Trailing Debounce
Trailing (default)
Runs AFTER delay ends.
Leading
Runs immediately, then blocks until delay ends.
Example (leading):

function debounce(fn, delay) {
    let timer;
    return function (...args) {
        if (!timer) {
            fn.apply(this, args);
        }

        clearTimeout(timer);

        timer = setTimeout(() => {
            timer = null;
        }, delay);
    };
}